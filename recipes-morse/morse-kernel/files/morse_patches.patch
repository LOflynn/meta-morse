diff --git a/drivers/mmc/core/card.h b/drivers/mmc/core/card.h
index 5c6986131faf..6a73e6988a14 100644
--- a/drivers/mmc/core/card.h
+++ b/drivers/mmc/core/card.h
@@ -59,6 +59,9 @@ struct mmc_fixup {
 	/* for MMC cards */
 	unsigned int ext_csd_rev;
 
+	/* Match against functions declared in device tree */
+	const char *of_compatible;
+
 	void (*vendor_fixup)(struct mmc_card *card, int data);
 	int data;
 };
@@ -120,6 +123,21 @@ struct mmc_fixup {
 		   _vendor, _device,					\
 		   _fixup, _data, EXT_CSD_REV_ANY)			\
 
+#define SDIO_FIXUP_COMPATIBLE(_compatible, _fixup, _data)		\
+	{						\
+		.name = CID_NAME_ANY,			\
+		.manfid = CID_MANFID_ANY,		\
+		.oemid = CID_OEMID_ANY,			\
+		.rev_start = 0,				\
+		.rev_end = -1ull,			\
+		.cis_vendor = SDIO_ANY_ID,		\
+		.cis_device = SDIO_ANY_ID,		\
+		.vendor_fixup = (_fixup),		\
+		.data = (_data),			\
+		.ext_csd_rev = EXT_CSD_REV_ANY,		\
+		.of_compatible = _compatible,	\
+	}
+
 #define cid_rev(hwrev, fwrev, year, month)	\
 	(((u64) hwrev) << 40 |			\
 	 ((u64) fwrev) << 32 |			\
diff --git a/drivers/mmc/core/quirks.h b/drivers/mmc/core/quirks.h
index 20380a8fdba2..381f548b5830 100644
--- a/drivers/mmc/core/quirks.h
+++ b/drivers/mmc/core/quirks.h
@@ -10,6 +10,7 @@
  *
  */
 
+#include <linux/of.h>
 #include <linux/mmc/sdio_ids.h>
 
 #include "card.h"
@@ -159,6 +160,29 @@ static const struct mmc_fixup __maybe_unused sdio_fixup_methods[] = {
 	END_FIXUP
 };
 
+static const struct mmc_fixup __maybe_unused sdio_card_init_methods[] = {
+	SDIO_FIXUP_COMPATIBLE("morse,mm6104", add_quirk, MMC_QUIRK_NO_18V),
+
+	SDIO_FIXUP_COMPATIBLE("morse,mm6108", add_quirk, MMC_QUIRK_NO_18V),
+
+	END_FIXUP
+};
+
+static inline bool mmc_fixup_of_compatible_match(struct mmc_card *card,
+						 const char *compatible)
+{
+	struct device_node *np;
+
+	for_each_child_of_node(mmc_dev(card->host)->of_node, np) {
+		if (of_device_is_compatible(np, compatible)) {
+			of_node_put(np);
+			return true;
+		}
+	}
+
+	return false;
+}
+
 static inline void mmc_fixup_device(struct mmc_card *card,
 				    const struct mmc_fixup *table)
 {
@@ -166,22 +190,32 @@ static inline void mmc_fixup_device(struct mmc_card *card,
 	u64 rev = cid_rev_card(card);
 
 	for (f = table; f->vendor_fixup; f++) {
-		if ((f->manfid == CID_MANFID_ANY ||
-		     f->manfid == card->cid.manfid) &&
-		    (f->oemid == CID_OEMID_ANY ||
-		     f->oemid == card->cid.oemid) &&
-		    (f->name == CID_NAME_ANY ||
-		     !strncmp(f->name, card->cid.prod_name,
-			      sizeof(card->cid.prod_name))) &&
-		    (f->cis_vendor == card->cis.vendor ||
-		     f->cis_vendor == (u16) SDIO_ANY_ID) &&
-		    (f->cis_device == card->cis.device ||
-		     f->cis_device == (u16) SDIO_ANY_ID) &&
-		    (f->ext_csd_rev == EXT_CSD_REV_ANY ||
-		     f->ext_csd_rev == card->ext_csd.rev) &&
-		    rev >= f->rev_start && rev <= f->rev_end) {
-			dev_dbg(&card->dev, "calling %ps\n", f->vendor_fixup);
-			f->vendor_fixup(card, f->data);
-		}
+		if (f->manfid != CID_MANFID_ANY &&
+		    f->manfid != card->cid.manfid)
+			continue;
+		if (f->oemid != CID_OEMID_ANY &&
+		    f->oemid != card->cid.oemid)
+			continue;
+		if (f->name != CID_NAME_ANY &&
+		    strncmp(f->name, card->cid.prod_name,
+			    sizeof(card->cid.prod_name)))
+			continue;
+		if (f->cis_vendor != (u16)SDIO_ANY_ID &&
+		    f->cis_vendor != card->cis.vendor)
+			continue;
+		if (f->cis_device != (u16)SDIO_ANY_ID &&
+		    f->cis_device != card->cis.device)
+			continue;
+		if (f->ext_csd_rev != EXT_CSD_REV_ANY &&
+		    f->ext_csd_rev != card->ext_csd.rev)
+			continue;
+		if (rev < f->rev_start || rev > f->rev_end)
+			continue;
+		if (f->of_compatible &&
+		    !mmc_fixup_of_compatible_match(card, f->of_compatible))
+			continue;
+
+		dev_dbg(&card->dev, "calling %ps\n", f->vendor_fixup);
+		f->vendor_fixup(card, f->data);
 	}
 }
diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 5447c47157aa..3d8a58374398 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -707,6 +707,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	 */
 	if (host->ops->init_card)
 		host->ops->init_card(host, card);
+	mmc_fixup_device(card, sdio_card_init_methods);
 
 	card->ocr = ocr_card;
 
@@ -721,7 +722,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	 * try to init uhs card. sdio_read_cccr will take over this task
 	 * to make sure which speed mode should work.
 	 */
-	if (rocr & ocr & R4_18V_PRESENT) {
+	if ((rocr & ocr & R4_18V_PRESENT) && !(card->quirks & MMC_QUIRK_NO_18V)) {
 		err = mmc_set_uhs_voltage(host, ocr_card);
 		if (err == -EAGAIN) {
 			mmc_sdio_pre_init(host, ocr_card, card);
diff --git a/drivers/spi/spi-bcm2835.c b/drivers/spi/spi-bcm2835.c
index 360c2c95f3b9..9ae399393620 100644
--- a/drivers/spi/spi-bcm2835.c
+++ b/drivers/spi/spi-bcm2835.c
@@ -25,9 +25,7 @@
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_device.h>
-#include <linux/gpio/consumer.h>
-#include <linux/gpio/machine.h> /* FIXME: using chip internals */
-#include <linux/gpio/driver.h> /* FIXME: using chip internals */
+#include <linux/of_gpio.h>
 #include <linux/of_irq.h>
 #include <linux/spi/spi.h>
 
@@ -74,7 +72,7 @@
 #define DRV_NAME	"spi-bcm2835"
 
 /* define polling limits */
-static unsigned int polling_limit_us = 30;
+unsigned int polling_limit_us = 30;
 module_param(polling_limit_us, uint, 0664);
 MODULE_PARM_DESC(polling_limit_us,
 		 "time in us to run a transfer in polling mode\n");
@@ -83,10 +81,8 @@ MODULE_PARM_DESC(polling_limit_us,
  * struct bcm2835_spi - BCM2835 SPI controller
  * @regs: base address of register map
  * @clk: core clock, divided to calculate serial clock
- * @clk_hz: core clock cached speed
  * @irq: interrupt, signals TX FIFO empty or RX FIFO Â¾ full
  * @tfr: SPI transfer currently processed
- * @ctlr: SPI controller reverse lookup
  * @tx_buf: pointer whence next transmitted byte is read
  * @rx_buf: pointer where next received byte is written
  * @tx_len: remaining bytes to transmit
@@ -96,6 +92,7 @@ MODULE_PARM_DESC(polling_limit_us,
  * @rx_prologue: bytes received without DMA if first RX sglist entry's
  *	length is not a multiple of 4 (to overcome hardware limitation)
  * @tx_spillover: whether @tx_prologue spills over to second TX sglist entry
+ * @dma_pending: whether a DMA transfer is in progress
  * @debugfs_dir: the debugfs directory - neede to remove debugfs when
  *      unloading the module
  * @count_transfer_polling: count of how often polling mode is used
@@ -105,19 +102,10 @@ MODULE_PARM_DESC(polling_limit_us,
  *      These are counted as well in @count_transfer_polling and
  *      @count_transfer_irq
  * @count_transfer_dma: count how often dma mode is used
- * @slv: SPI slave currently selected
- *	(used by bcm2835_spi_dma_tx_done() to write @clear_rx_cs)
- * @tx_dma_active: whether a TX DMA descriptor is in progress
- * @rx_dma_active: whether a RX DMA descriptor is in progress
- *	(used by bcm2835_spi_dma_tx_done() to handle a race)
- * @fill_tx_desc: preallocated TX DMA descriptor used for RX-only transfers
- *	(cyclically copies from zero page to TX FIFO)
- * @fill_tx_addr: bus address of zero page
  */
 struct bcm2835_spi {
 	void __iomem *regs;
 	struct clk *clk;
-	unsigned long clk_hz;
 	int irq;
 	struct spi_transfer *tfr;
 	struct spi_controller *ctlr;
@@ -128,35 +116,13 @@ struct bcm2835_spi {
 	int tx_prologue;
 	int rx_prologue;
 	unsigned int tx_spillover;
+	unsigned int dma_pending;
 
 	struct dentry *debugfs_dir;
 	u64 count_transfer_polling;
 	u64 count_transfer_irq;
 	u64 count_transfer_irq_after_polling;
 	u64 count_transfer_dma;
-
-	struct bcm2835_spidev *slv;
-	unsigned int tx_dma_active;
-	unsigned int rx_dma_active;
-	struct dma_async_tx_descriptor *fill_tx_desc;
-	dma_addr_t fill_tx_addr;
-};
-
-/**
- * struct bcm2835_spidev - BCM2835 SPI slave
- * @prepare_cs: precalculated CS register value for ->prepare_message()
- *	(uses slave-specific clock polarity and phase settings)
- * @clear_rx_desc: preallocated RX DMA descriptor used for TX-only transfers
- *	(cyclically clears RX FIFO by writing @clear_rx_cs to CS register)
- * @clear_rx_addr: bus address of @clear_rx_cs
- * @clear_rx_cs: precalculated CS register value to clear RX FIFO
- *	(uses slave-specific clock polarity and phase settings)
- */
-struct bcm2835_spidev {
-	u32 prepare_cs;
-	struct dma_async_tx_descriptor *clear_rx_desc;
-	dma_addr_t clear_rx_addr;
-	u32 clear_rx_cs ____cacheline_aligned;
 };
 
 #if defined(CONFIG_DEBUG_FS)
@@ -200,12 +166,12 @@ static void bcm2835_debugfs_remove(struct bcm2835_spi *bs)
 }
 #endif /* CONFIG_DEBUG_FS */
 
-static inline u32 bcm2835_rd(struct bcm2835_spi *bs, unsigned int reg)
+static inline u32 bcm2835_rd(struct bcm2835_spi *bs, unsigned reg)
 {
 	return readl(bs->regs + reg);
 }
 
-static inline void bcm2835_wr(struct bcm2835_spi *bs, unsigned int reg, u32 val)
+static inline void bcm2835_wr(struct bcm2835_spi *bs, unsigned reg, u32 val)
 {
 	writel(val, bs->regs + reg);
 }
@@ -252,13 +218,13 @@ static inline void bcm2835_rd_fifo_count(struct bcm2835_spi *bs, int count)
 
 	bs->rx_len -= count;
 
-	do {
+	while (count > 0) {
 		val = bcm2835_rd(bs, BCM2835_SPI_FIFO);
 		len = min(count, 4);
 		memcpy(bs->rx_buf, &val, len);
 		bs->rx_buf += len;
 		count -= 4;
-	} while (count > 0);
+	}
 }
 
 /**
@@ -278,7 +244,7 @@ static inline void bcm2835_wr_fifo_count(struct bcm2835_spi *bs, int count)
 
 	bs->tx_len -= count;
 
-	do {
+	while (count > 0) {
 		if (bs->tx_buf) {
 			len = min(count, 4);
 			memcpy(&val, bs->tx_buf, len);
@@ -288,7 +254,7 @@ static inline void bcm2835_wr_fifo_count(struct bcm2835_spi *bs, int count)
 		}
 		bcm2835_wr(bs, BCM2835_SPI_FIFO, val);
 		count -= 4;
-	} while (count > 0);
+	}
 }
 
 /**
@@ -317,11 +283,12 @@ static inline void bcm2835_rd_fifo_blind(struct bcm2835_spi *bs, int count)
 	count = min(count, bs->rx_len);
 	bs->rx_len -= count;
 
-	do {
+	while (count) {
 		val = bcm2835_rd(bs, BCM2835_SPI_FIFO);
 		if (bs->rx_buf)
 			*bs->rx_buf++ = val;
-	} while (--count);
+		count--;
+	}
 }
 
 /**
@@ -336,14 +303,16 @@ static inline void bcm2835_wr_fifo_blind(struct bcm2835_spi *bs, int count)
 	count = min(count, bs->tx_len);
 	bs->tx_len -= count;
 
-	do {
+	while (count) {
 		val = bs->tx_buf ? *bs->tx_buf++ : 0;
 		bcm2835_wr(bs, BCM2835_SPI_FIFO, val);
-	} while (--count);
+		count--;
+	}
 }
 
-static void bcm2835_spi_reset_hw(struct bcm2835_spi *bs)
+static void bcm2835_spi_reset_hw(struct spi_controller *ctlr)
 {
+	struct bcm2835_spi *bs = spi_controller_get_devdata(ctlr);
 	u32 cs = bcm2835_rd(bs, BCM2835_SPI_CS);
 
 	/* Disable SPI interrupts and transfer */
@@ -351,13 +320,6 @@ static void bcm2835_spi_reset_hw(struct bcm2835_spi *bs)
 		BCM2835_SPI_CS_INTD |
 		BCM2835_SPI_CS_DMAEN |
 		BCM2835_SPI_CS_TA);
-	/*
-	 * Transmission sometimes breaks unless the DONE bit is written at the
-	 * end of every transfer.  The spec says it's a RO bit.  Either the
-	 * spec is wrong and the bit is actually of type RW1C, or it's a
-	 * hardware erratum.
-	 */
-	cs |= BCM2835_SPI_CS_DONE;
 	/* and reset RX/TX FIFOS */
 	cs |= BCM2835_SPI_CS_CLEAR_RX | BCM2835_SPI_CS_CLEAR_TX;
 
@@ -369,7 +331,8 @@ static void bcm2835_spi_reset_hw(struct bcm2835_spi *bs)
 
 static irqreturn_t bcm2835_spi_interrupt(int irq, void *dev_id)
 {
-	struct bcm2835_spi *bs = dev_id;
+	struct spi_controller *ctlr = dev_id;
+	struct bcm2835_spi *bs = spi_controller_get_devdata(ctlr);
 	u32 cs = bcm2835_rd(bs, BCM2835_SPI_CS);
 
 	/* Bail out early if interrupts are not enabled */
@@ -395,7 +358,7 @@ static irqreturn_t bcm2835_spi_interrupt(int irq, void *dev_id)
 
 	if (!bs->rx_len) {
 		/* Transfer complete - reset SPI HW */
-		bcm2835_spi_reset_hw(bs);
+		bcm2835_spi_reset_hw(ctlr);
 		/* wake up the framework */
 		spi_finalize_current_transfer(bs->ctlr);
 	}
@@ -490,14 +453,14 @@ static void bcm2835_spi_transfer_prologue(struct spi_controller *ctlr,
 	bs->rx_prologue  = 0;
 	bs->tx_spillover = false;
 
-	if (bs->tx_buf && !sg_is_last(&tfr->tx_sg.sgl[0]))
+	if (!sg_is_last(&tfr->tx_sg.sgl[0]))
 		bs->tx_prologue = sg_dma_len(&tfr->tx_sg.sgl[0]) & 3;
 
-	if (bs->rx_buf && !sg_is_last(&tfr->rx_sg.sgl[0])) {
+	if (!sg_is_last(&tfr->rx_sg.sgl[0])) {
 		bs->rx_prologue = sg_dma_len(&tfr->rx_sg.sgl[0]) & 3;
 
 		if (bs->rx_prologue > bs->tx_prologue) {
-			if (!bs->tx_buf || sg_is_last(&tfr->tx_sg.sgl[0])) {
+			if (sg_is_last(&tfr->tx_sg.sgl[0])) {
 				bs->tx_prologue  = bs->rx_prologue;
 			} else {
 				bs->tx_prologue += 4;
@@ -519,9 +482,7 @@ static void bcm2835_spi_transfer_prologue(struct spi_controller *ctlr,
 		bcm2835_wr_fifo_count(bs, bs->rx_prologue);
 		bcm2835_wait_tx_fifo_empty(bs);
 		bcm2835_rd_fifo_count(bs, bs->rx_prologue);
-		bcm2835_wr(bs, BCM2835_SPI_CS, cs | BCM2835_SPI_CS_CLEAR_RX
-						  | BCM2835_SPI_CS_CLEAR_TX
-						  | BCM2835_SPI_CS_DONE);
+		bcm2835_spi_reset_hw(ctlr);
 
 		dma_sync_single_for_device(ctlr->dma_rx->device->dev,
 					   sg_dma_address(&tfr->rx_sg.sgl[0]),
@@ -531,9 +492,6 @@ static void bcm2835_spi_transfer_prologue(struct spi_controller *ctlr,
 		sg_dma_len(&tfr->rx_sg.sgl[0])     -= bs->rx_prologue;
 	}
 
-	if (!bs->tx_buf)
-		return;
-
 	/*
 	 * Write remaining TX prologue.  Adjust first entry in TX sglist.
 	 * Also adjust second entry if prologue spills over to it.
@@ -545,8 +503,7 @@ static void bcm2835_spi_transfer_prologue(struct spi_controller *ctlr,
 						  | BCM2835_SPI_CS_DMAEN);
 		bcm2835_wr_fifo_count(bs, tx_remaining);
 		bcm2835_wait_tx_fifo_empty(bs);
-		bcm2835_wr(bs, BCM2835_SPI_CS, cs | BCM2835_SPI_CS_CLEAR_TX
-						  | BCM2835_SPI_CS_DONE);
+		bcm2835_wr(bs, BCM2835_SPI_CS, cs | BCM2835_SPI_CS_CLEAR_TX);
 	}
 
 	if (likely(!bs->tx_spillover)) {
@@ -579,9 +536,6 @@ static void bcm2835_spi_undo_prologue(struct bcm2835_spi *bs)
 		sg_dma_len(&tfr->rx_sg.sgl[0])     += bs->rx_prologue;
 	}
 
-	if (!bs->tx_buf)
-		goto out;
-
 	if (likely(!bs->tx_spillover)) {
 		sg_dma_address(&tfr->tx_sg.sgl[0]) -= bs->tx_prologue;
 		sg_dma_len(&tfr->tx_sg.sgl[0])     += bs->tx_prologue;
@@ -590,84 +544,32 @@ static void bcm2835_spi_undo_prologue(struct bcm2835_spi *bs)
 		sg_dma_address(&tfr->tx_sg.sgl[1]) -= 4;
 		sg_dma_len(&tfr->tx_sg.sgl[1])     += 4;
 	}
-out:
-	bs->tx_prologue = 0;
 }
 
-/**
- * bcm2835_spi_dma_rx_done() - callback for DMA RX channel
- * @data: SPI master controller
- *
- * Used for bidirectional and RX-only transfers.
- */
-static void bcm2835_spi_dma_rx_done(void *data)
+static void bcm2835_spi_dma_done(void *data)
 {
 	struct spi_controller *ctlr = data;
 	struct bcm2835_spi *bs = spi_controller_get_devdata(ctlr);
 
-	/* terminate tx-dma as we do not have an irq for it
+	/* reset fifo and HW */
+	bcm2835_spi_reset_hw(ctlr);
+
+	/* and terminate tx-dma as we do not have an irq for it
 	 * because when the rx dma will terminate and this callback
 	 * is called the tx-dma must have finished - can't get to this
 	 * situation otherwise...
 	 */
-	dmaengine_terminate_async(ctlr->dma_tx);
-	bs->tx_dma_active = false;
-	bs->rx_dma_active = false;
-	bcm2835_spi_undo_prologue(bs);
-
-	/* reset fifo and HW */
-	bcm2835_spi_reset_hw(bs);
 
+	if (cmpxchg(&bs->dma_pending, true, false)) {
+		dmaengine_terminate_async(ctlr->dma_tx);
+		bcm2835_spi_undo_prologue(bs);
+	}
 	/* and mark as completed */;
 	spi_finalize_current_transfer(ctlr);
 }
 
-/**
- * bcm2835_spi_dma_tx_done() - callback for DMA TX channel
- * @data: SPI master controller
- *
- * Used for TX-only transfers.
- */
-static void bcm2835_spi_dma_tx_done(void *data)
-{
-	struct spi_controller *ctlr = data;
-	struct bcm2835_spi *bs = spi_controller_get_devdata(ctlr);
-
-	/* busy-wait for TX FIFO to empty */
-	while (!(bcm2835_rd(bs, BCM2835_SPI_CS) & BCM2835_SPI_CS_DONE))
-		bcm2835_wr(bs, BCM2835_SPI_CS, bs->slv->clear_rx_cs);
-
-	bs->tx_dma_active = false;
-	smp_wmb();
-
-	/*
-	 * In case of a very short transfer, RX DMA may not have been
-	 * issued yet.  The onus is then on bcm2835_spi_transfer_one_dma()
-	 * to terminate it immediately after issuing.
-	 */
-	if (cmpxchg(&bs->rx_dma_active, true, false))
-		dmaengine_terminate_async(ctlr->dma_rx);
-
-	bcm2835_spi_undo_prologue(bs);
-	bcm2835_spi_reset_hw(bs);
-	spi_finalize_current_transfer(ctlr);
-}
-
-/**
- * bcm2835_spi_prepare_sg() - prepare and submit DMA descriptor for sglist
- * @ctlr: SPI master controller
- * @tfr: SPI transfer
- * @bs: BCM2835 SPI controller
- * @slv: BCM2835 SPI slave
- * @is_tx: whether to submit DMA descriptor for TX or RX sglist
- *
- * Prepare and submit a DMA descriptor for the TX or RX sglist of @tfr.
- * Return 0 on success or a negative error number.
- */
 static int bcm2835_spi_prepare_sg(struct spi_controller *ctlr,
 				  struct spi_transfer *tfr,
-				  struct bcm2835_spi *bs,
-				  struct bcm2835_spidev *slv,
 				  bool is_tx)
 {
 	struct dma_chan *chan;
@@ -684,7 +586,7 @@ static int bcm2835_spi_prepare_sg(struct spi_controller *ctlr,
 		chan  = ctlr->dma_tx;
 		nents = tfr->tx_sg.nents;
 		sgl   = tfr->tx_sg.sgl;
-		flags = tfr->rx_buf ? 0 : DMA_PREP_INTERRUPT;
+		flags = 0 /* no  tx interrupt */;
 	} else {
 		dir   = DMA_DEV_TO_MEM;
 		chan  = ctlr->dma_rx;
@@ -697,17 +599,10 @@ static int bcm2835_spi_prepare_sg(struct spi_controller *ctlr,
 	if (!desc)
 		return -EINVAL;
 
-	/*
-	 * Completion is signaled by the RX channel for bidirectional and
-	 * RX-only transfers; else by the TX channel for TX-only transfers.
-	 */
+	/* set callback for rx */
 	if (!is_tx) {
-		desc->callback = bcm2835_spi_dma_rx_done;
-		desc->callback_param = ctlr;
-	} else if (!tfr->rx_buf) {
-		desc->callback = bcm2835_spi_dma_tx_done;
+		desc->callback = bcm2835_spi_dma_done;
 		desc->callback_param = ctlr;
-		bs->slv = slv;
 	}
 
 	/* submit it to DMA-engine */
@@ -716,60 +611,12 @@ static int bcm2835_spi_prepare_sg(struct spi_controller *ctlr,
 	return dma_submit_error(cookie);
 }
 
-/**
- * bcm2835_spi_transfer_one_dma() - perform SPI transfer using DMA engine
- * @ctlr: SPI master controller
- * @tfr: SPI transfer
- * @slv: BCM2835 SPI slave
- * @cs: CS register
- *
- * For *bidirectional* transfers (both tx_buf and rx_buf are non-%NULL), set up
- * the TX and RX DMA channel to copy between memory and FIFO register.
- *
- * For *TX-only* transfers (rx_buf is %NULL), copying the RX FIFO's contents to
- * memory is pointless.  However not reading the RX FIFO isn't an option either
- * because transmission is halted once it's full.  As a workaround, cyclically
- * clear the RX FIFO by setting the CLEAR_RX bit in the CS register.
- *
- * The CS register value is precalculated in bcm2835_spi_setup().  Normally
- * this is called only once, on slave registration.  A DMA descriptor to write
- * this value is preallocated in bcm2835_dma_init().  All that's left to do
- * when performing a TX-only transfer is to submit this descriptor to the RX
- * DMA channel.  Latency is thereby minimized.  The descriptor does not
- * generate any interrupts while running.  It must be terminated once the
- * TX DMA channel is done.
- *
- * Clearing the RX FIFO is paced by the DREQ signal.  The signal is asserted
- * when the RX FIFO becomes half full, i.e. 32 bytes.  (Tuneable with the DC
- * register.)  Reading 32 bytes from the RX FIFO would normally require 8 bus
- * accesses, whereas clearing it requires only 1 bus access.  So an 8-fold
- * reduction in bus traffic and thus energy consumption is achieved.
- *
- * For *RX-only* transfers (tx_buf is %NULL), fill the TX FIFO by cyclically
- * copying from the zero page.  The DMA descriptor to do this is preallocated
- * in bcm2835_dma_init().  It must be terminated once the RX DMA channel is
- * done and can then be reused.
- *
- * The BCM2835 DMA driver autodetects when a transaction copies from the zero
- * page and utilizes the DMA controller's ability to synthesize zeroes instead
- * of copying them from memory.  This reduces traffic on the memory bus.  The
- * feature is not available on so-called "lite" channels, but normally TX DMA
- * is backed by a full-featured channel.
- *
- * Zero-filling the TX FIFO is paced by the DREQ signal.  Unfortunately the
- * BCM2835 SPI controller continues to assert DREQ even after the DLEN register
- * has been counted down to zero (hardware erratum).  Thus, when the transfer
- * has finished, the DMA engine zero-fills the TX FIFO until it is half full.
- * (Tuneable with the DC register.)  So up to 9 gratuitous bus accesses are
- * performed at the end of an RX-only transfer.
- */
 static int bcm2835_spi_transfer_one_dma(struct spi_controller *ctlr,
+					struct spi_device *spi,
 					struct spi_transfer *tfr,
-					struct bcm2835_spidev *slv,
 					u32 cs)
 {
 	struct bcm2835_spi *bs = spi_controller_get_devdata(ctlr);
-	dma_cookie_t cookie;
 	int ret;
 
 	/* update usage statistics */
@@ -782,15 +629,16 @@ static int bcm2835_spi_transfer_one_dma(struct spi_controller *ctlr,
 	bcm2835_spi_transfer_prologue(ctlr, tfr, bs, cs);
 
 	/* setup tx-DMA */
-	if (bs->tx_buf) {
-		ret = bcm2835_spi_prepare_sg(ctlr, tfr, bs, slv, true);
-	} else {
-		cookie = dmaengine_submit(bs->fill_tx_desc);
-		ret = dma_submit_error(cookie);
-	}
+	ret = bcm2835_spi_prepare_sg(ctlr, tfr, true);
 	if (ret)
 		goto err_reset_hw;
 
+	/* start TX early */
+	dma_async_issue_pending(ctlr->dma_tx);
+
+	/* mark as dma pending */
+	bs->dma_pending = 1;
+
 	/* set the DMA length */
 	bcm2835_wr(bs, BCM2835_SPI_DLEN, bs->tx_len);
 
@@ -798,49 +646,26 @@ static int bcm2835_spi_transfer_one_dma(struct spi_controller *ctlr,
 	bcm2835_wr(bs, BCM2835_SPI_CS,
 		   cs | BCM2835_SPI_CS_TA | BCM2835_SPI_CS_DMAEN);
 
-	bs->tx_dma_active = true;
-	smp_wmb();
-
-	/* start TX early */
-	dma_async_issue_pending(ctlr->dma_tx);
-
 	/* setup rx-DMA late - to run transfers while
 	 * mapping of the rx buffers still takes place
 	 * this saves 10us or more.
 	 */
-	if (bs->rx_buf) {
-		ret = bcm2835_spi_prepare_sg(ctlr, tfr, bs, slv, false);
-	} else {
-		cookie = dmaengine_submit(slv->clear_rx_desc);
-		ret = dma_submit_error(cookie);
-	}
+	ret = bcm2835_spi_prepare_sg(ctlr, tfr, false);
 	if (ret) {
 		/* need to reset on errors */
 		dmaengine_terminate_sync(ctlr->dma_tx);
-		bs->tx_dma_active = false;
+		bs->dma_pending = false;
 		goto err_reset_hw;
 	}
 
 	/* start rx dma late */
 	dma_async_issue_pending(ctlr->dma_rx);
-	bs->rx_dma_active = true;
-	smp_mb();
-
-	/*
-	 * In case of a very short TX-only transfer, bcm2835_spi_dma_tx_done()
-	 * may run before RX DMA is issued.  Terminate RX DMA if so.
-	 */
-	if (!bs->rx_buf && !bs->tx_dma_active &&
-	    cmpxchg(&bs->rx_dma_active, true, false)) {
-		dmaengine_terminate_async(ctlr->dma_rx);
-		bcm2835_spi_reset_hw(bs);
-	}
 
 	/* wait for wakeup in framework */
 	return 1;
 
 err_reset_hw:
-	bcm2835_spi_reset_hw(bs);
+	bcm2835_spi_reset_hw(ctlr);
 	bcm2835_spi_undo_prologue(bs);
 	return ret;
 }
@@ -857,21 +682,10 @@ static bool bcm2835_spi_can_dma(struct spi_controller *ctlr,
 	return true;
 }
 
-static void bcm2835_dma_release(struct spi_controller *ctlr,
-				struct bcm2835_spi *bs)
+static void bcm2835_dma_release(struct spi_controller *ctlr)
 {
 	if (ctlr->dma_tx) {
 		dmaengine_terminate_sync(ctlr->dma_tx);
-
-		if (bs->fill_tx_desc)
-			dmaengine_desc_free(bs->fill_tx_desc);
-
-		if (bs->fill_tx_addr)
-			dma_unmap_page_attrs(ctlr->dma_tx->device->dev,
-					     bs->fill_tx_addr, sizeof(u32),
-					     DMA_TO_DEVICE,
-					     DMA_ATTR_SKIP_CPU_SYNC);
-
 		dma_release_channel(ctlr->dma_tx);
 		ctlr->dma_tx = NULL;
 	}
@@ -883,8 +697,7 @@ static void bcm2835_dma_release(struct spi_controller *ctlr,
 	}
 }
 
-static int bcm2835_dma_init(struct spi_controller *ctlr, struct device *dev,
-			    struct bcm2835_spi *bs)
+static void bcm2835_dma_init(struct spi_controller *ctlr, struct device *dev)
 {
 	struct dma_slave_config slave_config;
 	const __be32 *addr;
@@ -895,32 +708,23 @@ static int bcm2835_dma_init(struct spi_controller *ctlr, struct device *dev,
 	addr = of_get_address(ctlr->dev.of_node, 0, NULL, NULL);
 	if (!addr) {
 		dev_err(dev, "could not get DMA-register address - not using dma mode\n");
-		/* Fall back to interrupt mode */
-		return 0;
+		goto err;
 	}
 	dma_reg_base = be32_to_cpup(addr);
 
 	/* get tx/rx dma */
-	ctlr->dma_tx = dma_request_chan(dev, "tx");
-	if (IS_ERR(ctlr->dma_tx)) {
+	ctlr->dma_tx = dma_request_slave_channel(dev, "tx");
+	if (!ctlr->dma_tx) {
 		dev_err(dev, "no tx-dma configuration found - not using dma mode\n");
-		ret = PTR_ERR(ctlr->dma_tx);
-		ctlr->dma_tx = NULL;
 		goto err;
 	}
-	ctlr->dma_rx = dma_request_chan(dev, "rx");
-	if (IS_ERR(ctlr->dma_rx)) {
+	ctlr->dma_rx = dma_request_slave_channel(dev, "rx");
+	if (!ctlr->dma_rx) {
 		dev_err(dev, "no rx-dma configuration found - not using dma mode\n");
-		ret = PTR_ERR(ctlr->dma_rx);
-		ctlr->dma_rx = NULL;
 		goto err_release;
 	}
 
-	/*
-	 * The TX DMA channel either copies a transfer's TX buffer to the FIFO
-	 * or, in case of an RX-only transfer, cyclically copies from the zero
-	 * page to the FIFO using a preallocated, reusable descriptor.
-	 */
+	/* configure DMAs */
 	slave_config.dst_addr = (u32)(dma_reg_base + BCM2835_SPI_FIFO);
 	slave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 
@@ -928,42 +732,8 @@ static int bcm2835_dma_init(struct spi_controller *ctlr, struct device *dev,
 	if (ret)
 		goto err_config;
 
-	bs->fill_tx_addr = dma_map_page_attrs(ctlr->dma_tx->device->dev,
-					      ZERO_PAGE(0), 0, sizeof(u32),
-					      DMA_TO_DEVICE,
-					      DMA_ATTR_SKIP_CPU_SYNC);
-	if (dma_mapping_error(ctlr->dma_tx->device->dev, bs->fill_tx_addr)) {
-		dev_err(dev, "cannot map zero page - not using DMA mode\n");
-		bs->fill_tx_addr = 0;
-		ret = -ENOMEM;
-		goto err_release;
-	}
-
-	bs->fill_tx_desc = dmaengine_prep_dma_cyclic(ctlr->dma_tx,
-						     bs->fill_tx_addr,
-						     sizeof(u32), 0,
-						     DMA_MEM_TO_DEV, 0);
-	if (!bs->fill_tx_desc) {
-		dev_err(dev, "cannot prepare fill_tx_desc - not using DMA mode\n");
-		ret = -ENOMEM;
-		goto err_release;
-	}
-
-	ret = dmaengine_desc_set_reuse(bs->fill_tx_desc);
-	if (ret) {
-		dev_err(dev, "cannot reuse fill_tx_desc - not using DMA mode\n");
-		goto err_release;
-	}
-
-	/*
-	 * The RX DMA channel is used bidirectionally:  It either reads the
-	 * RX FIFO or, in case of a TX-only transfer, cyclically writes a
-	 * precalculated value to the CS register to clear the RX FIFO.
-	 */
 	slave_config.src_addr = (u32)(dma_reg_base + BCM2835_SPI_FIFO);
 	slave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	slave_config.dst_addr = (u32)(dma_reg_base + BCM2835_SPI_CS);
-	slave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 
 	ret = dmaengine_slave_config(ctlr->dma_rx, &slave_config);
 	if (ret)
@@ -971,23 +741,18 @@ static int bcm2835_dma_init(struct spi_controller *ctlr, struct device *dev,
 
 	/* all went well, so set can_dma */
 	ctlr->can_dma = bcm2835_spi_can_dma;
+	/* need to do TX AND RX DMA, so we need dummy buffers */
+	ctlr->flags = SPI_CONTROLLER_MUST_RX | SPI_CONTROLLER_MUST_TX;
 
-	return 0;
+	return;
 
 err_config:
 	dev_err(dev, "issue configuring dma: %d - not using DMA mode\n",
 		ret);
 err_release:
-	bcm2835_dma_release(ctlr, bs);
+	bcm2835_dma_release(ctlr);
 err:
-	/*
-	 * Only report error for deferred probing, otherwise fall back to
-	 * interrupt mode
-	 */
-	if (ret != -EPROBE_DEFER)
-		ret = 0;
-
-	return ret;
+	return;
 }
 
 static int bcm2835_spi_transfer_one_poll(struct spi_controller *ctlr,
@@ -1040,7 +805,7 @@ static int bcm2835_spi_transfer_one_poll(struct spi_controller *ctlr,
 	}
 
 	/* Transfer complete - reset SPI HW */
-	bcm2835_spi_reset_hw(bs);
+	bcm2835_spi_reset_hw(ctlr);
 	/* and return without waiting for completion */
 	return 0;
 }
@@ -1050,29 +815,19 @@ static int bcm2835_spi_transfer_one(struct spi_controller *ctlr,
 				    struct spi_transfer *tfr)
 {
 	struct bcm2835_spi *bs = spi_controller_get_devdata(ctlr);
-	struct bcm2835_spidev *slv = spi_get_ctldata(spi);
-	unsigned long spi_hz, cdiv;
+	unsigned long spi_hz, clk_hz, cdiv, spi_used_hz;
 	unsigned long hz_per_byte, byte_limit;
-	u32 cs = slv->prepare_cs;
-
-	if (unlikely(!tfr->len)) {
-		static int warned;
-
-		if (!warned)
-			dev_warn(&spi->dev,
-				 "zero-length SPI transfer ignored\n");
-		warned = 1;
-		return 0;
-	}
+	u32 cs = bcm2835_rd(bs, BCM2835_SPI_CS);
 
 	/* set clock */
 	spi_hz = tfr->speed_hz;
+	clk_hz = clk_get_rate(bs->clk);
 
-	if (spi_hz >= bs->clk_hz / 2) {
+	if (spi_hz >= clk_hz / 2) {
 		cdiv = 2; /* clk_hz/2 is the fastest we can go */
 	} else if (spi_hz) {
 		/* CDIV must be a multiple of two */
-		cdiv = DIV_ROUND_UP(bs->clk_hz, spi_hz);
+		cdiv = DIV_ROUND_UP(clk_hz, spi_hz);
 		cdiv += (cdiv % 2);
 
 		if (cdiv >= 65536)
@@ -1080,12 +835,23 @@ static int bcm2835_spi_transfer_one(struct spi_controller *ctlr,
 	} else {
 		cdiv = 0; /* 0 is the slowest we can go */
 	}
-	tfr->effective_speed_hz = cdiv ? (bs->clk_hz / cdiv) : (bs->clk_hz / 65536);
+	spi_used_hz = cdiv ? (clk_hz / cdiv) : (clk_hz / 65536);
 	bcm2835_wr(bs, BCM2835_SPI_CLK, cdiv);
 
 	/* handle all the 3-wire mode */
-	if (spi->mode & SPI_3WIRE && tfr->rx_buf)
+	if (spi->mode & SPI_3WIRE && tfr->rx_buf &&
+		tfr->rx_buf != ctlr->dummy_rx)
 		cs |= BCM2835_SPI_CS_REN;
+	else
+		cs &= ~BCM2835_SPI_CS_REN;
+
+	/*
+	 * The driver always uses software-controlled GPIO Chip Select.
+	 * Set the hardware-controlled native Chip Select to an invalid
+	 * value to prevent it from interfering.
+	 */
+	cs |= BCM2835_SPI_CS_CS_10 | BCM2835_SPI_CS_CS_01;
+
 
 	/* set transmit buffers and length */
 	bs->tx_buf = tfr->tx_buf;
@@ -1100,7 +866,7 @@ static int bcm2835_spi_transfer_one(struct spi_controller *ctlr,
 	 * per 300,000 Hz of bus clock.
 	 */
 	hz_per_byte = polling_limit_us ? (9 * 1000000) / polling_limit_us : 0;
-	byte_limit = hz_per_byte ? tfr->effective_speed_hz / hz_per_byte : 1;
+	byte_limit = hz_per_byte ? spi_used_hz / hz_per_byte : 1;
 
 	/* run in polling mode for short transfers */
 	if (tfr->len < byte_limit)
@@ -1111,7 +877,7 @@ static int bcm2835_spi_transfer_one(struct spi_controller *ctlr,
 	 * this 1 idle clock cycle pattern but runs the spi clock without gaps
 	 */
 	if (ctlr->can_dma && bcm2835_spi_can_dma(ctlr, spi, tfr))
-		return bcm2835_spi_transfer_one_dma(ctlr, tfr, slv, cs);
+		return bcm2835_spi_transfer_one_dma(ctlr, spi, tfr, cs);
 
 	/* run in interrupt-mode */
 	return bcm2835_spi_transfer_one_irq(ctlr, spi, tfr, cs, true);
@@ -1122,7 +888,7 @@ static int bcm2835_spi_prepare_message(struct spi_controller *ctlr,
 {
 	struct spi_device *spi = msg->spi;
 	struct bcm2835_spi *bs = spi_controller_get_devdata(ctlr);
-	struct bcm2835_spidev *slv = spi_get_ctldata(spi);
+	u32 cs = bcm2835_rd(bs, BCM2835_SPI_CS);
 	int ret;
 
 	if (ctlr->can_dma) {
@@ -1137,11 +903,14 @@ static int bcm2835_spi_prepare_message(struct spi_controller *ctlr,
 			return ret;
 	}
 
-	/*
-	 * Set up clock polarity before spi_transfer_one_message() asserts
-	 * chip select to avoid a gratuitous clock signal edge.
-	 */
-	bcm2835_wr(bs, BCM2835_SPI_CS, slv->prepare_cs);
+	cs &= ~(BCM2835_SPI_CS_CPOL | BCM2835_SPI_CS_CPHA);
+
+	if (spi->mode & SPI_CPOL)
+		cs |= BCM2835_SPI_CS_CPOL;
+	if (spi->mode & SPI_CPHA)
+		cs |= BCM2835_SPI_CS_CPHA;
+
+	bcm2835_wr(bs, BCM2835_SPI_CS, cs);
 
 	return 0;
 }
@@ -1152,18 +921,14 @@ static void bcm2835_spi_handle_err(struct spi_controller *ctlr,
 	struct bcm2835_spi *bs = spi_controller_get_devdata(ctlr);
 
 	/* if an error occurred and we have an active dma, then terminate */
-	if (ctlr->dma_tx) {
+	if (cmpxchg(&bs->dma_pending, true, false)) {
 		dmaengine_terminate_sync(ctlr->dma_tx);
-		bs->tx_dma_active = false;
-	}
-	if (ctlr->dma_rx) {
 		dmaengine_terminate_sync(ctlr->dma_rx);
-		bs->rx_dma_active = false;
+		bcm2835_spi_undo_prologue(bs);
 	}
-	bcm2835_spi_undo_prologue(bs);
 
 	/* and reset */
-	bcm2835_spi_reset_hw(bs);
+	bcm2835_spi_reset_hw(ctlr);
 }
 
 static int chip_match_name(struct gpio_chip *chip, void *data)
@@ -1171,120 +936,17 @@ static int chip_match_name(struct gpio_chip *chip, void *data)
 	return !strcmp(chip->label, data);
 }
 
-static void bcm2835_spi_cleanup(struct spi_device *spi)
-{
-	struct bcm2835_spidev *slv = spi_get_ctldata(spi);
-	struct spi_controller *ctlr = spi->controller;
-
-	if (slv->clear_rx_desc)
-		dmaengine_desc_free(slv->clear_rx_desc);
-
-	if (slv->clear_rx_addr)
-		dma_unmap_single(ctlr->dma_rx->device->dev,
-				 slv->clear_rx_addr,
-				 sizeof(u32),
-				 DMA_TO_DEVICE);
-
-	kfree(slv);
-}
-
-static int bcm2835_spi_setup_dma(struct spi_controller *ctlr,
-				 struct spi_device *spi,
-				 struct bcm2835_spi *bs,
-				 struct bcm2835_spidev *slv)
-{
-	int ret;
-
-	if (!ctlr->dma_rx)
-		return 0;
-
-	slv->clear_rx_addr = dma_map_single(ctlr->dma_rx->device->dev,
-					    &slv->clear_rx_cs,
-					    sizeof(u32),
-					    DMA_TO_DEVICE);
-	if (dma_mapping_error(ctlr->dma_rx->device->dev, slv->clear_rx_addr)) {
-		dev_err(&spi->dev, "cannot map clear_rx_cs\n");
-		slv->clear_rx_addr = 0;
-		return -ENOMEM;
-	}
-
-	slv->clear_rx_desc = dmaengine_prep_dma_cyclic(ctlr->dma_rx,
-						       slv->clear_rx_addr,
-						       sizeof(u32), 0,
-						       DMA_MEM_TO_DEV, 0);
-	if (!slv->clear_rx_desc) {
-		dev_err(&spi->dev, "cannot prepare clear_rx_desc\n");
-		return -ENOMEM;
-	}
-
-	ret = dmaengine_desc_set_reuse(slv->clear_rx_desc);
-	if (ret) {
-		dev_err(&spi->dev, "cannot reuse clear_rx_desc\n");
-		return ret;
-	}
-
-	return 0;
-}
-
 static int bcm2835_spi_setup(struct spi_device *spi)
 {
-	struct spi_controller *ctlr = spi->controller;
-	struct bcm2835_spi *bs = spi_controller_get_devdata(ctlr);
-	struct bcm2835_spidev *slv = spi_get_ctldata(spi);
+	int err;
 	struct gpio_chip *chip;
-	int ret;
-	u32 cs;
-
-	if (!slv) {
-		slv = kzalloc(ALIGN(sizeof(*slv), dma_get_cache_alignment()),
-			      GFP_KERNEL);
-		if (!slv)
-			return -ENOMEM;
-
-		spi_set_ctldata(spi, slv);
-
-		ret = bcm2835_spi_setup_dma(ctlr, spi, bs, slv);
-		if (ret)
-			goto err_cleanup;
-	}
-
-	/*
-	 * Precalculate SPI slave's CS register value for ->prepare_message():
-	 * The driver always uses software-controlled GPIO chip select, hence
-	 * set the hardware-controlled native chip select to an invalid value
-	 * to prevent it from interfering.
-	 */
-	cs = BCM2835_SPI_CS_CS_10 | BCM2835_SPI_CS_CS_01;
-	if (spi->mode & SPI_CPOL)
-		cs |= BCM2835_SPI_CS_CPOL;
-	if (spi->mode & SPI_CPHA)
-		cs |= BCM2835_SPI_CS_CPHA;
-	slv->prepare_cs = cs;
-
-	/*
-	 * Precalculate SPI slave's CS register value to clear RX FIFO
-	 * in case of a TX-only DMA transfer.
-	 */
-	if (ctlr->dma_rx) {
-		slv->clear_rx_cs = cs | BCM2835_SPI_CS_TA |
-					BCM2835_SPI_CS_DMAEN |
-					BCM2835_SPI_CS_CLEAR_RX;
-		dma_sync_single_for_device(ctlr->dma_rx->device->dev,
-					   slv->clear_rx_addr,
-					   sizeof(u32),
-					   DMA_TO_DEVICE);
-	}
 
 	/*
 	 * sanity checking the native-chipselects
 	 */
 	if (spi->mode & SPI_NO_CS)
 		return 0;
-	/*
-	 * The SPI core has successfully requested the CS GPIO line from the
-	 * device tree, so we are done.
-	 */
-	if (spi->cs_gpiod)
+	if (gpio_is_valid(spi->cs_gpio))
 		return 0;
 	if (spi->chip_select > 1) {
 		/* error in the case of native CS requested with CS > 1
@@ -1293,62 +955,53 @@ static int bcm2835_spi_setup(struct spi_device *spi)
 		 */
 		dev_err(&spi->dev,
 			"setup: only two native chip-selects are supported\n");
-		ret = -EINVAL;
-		goto err_cleanup;
+		return -EINVAL;
 	}
 
-	/*
-	 * Translate native CS to GPIO
-	 *
-	 * FIXME: poking around in the gpiolib internals like this is
-	 * not very good practice. Find a way to locate the real problem
-	 * and fix it. Why is the GPIO descriptor in spi->cs_gpiod
-	 * sometimes not assigned correctly? Erroneous device trees?
-	 */
+	/* now translate native cs to GPIO */
 
 	/* get the gpio chip for the base */
 	chip = gpiochip_find("pinctrl-bcm2835", chip_match_name);
 	if (!chip)
 		return 0;
 
-	spi->cs_gpiod = gpiochip_request_own_desc(chip, 8 - spi->chip_select,
-						  DRV_NAME,
-						  GPIO_LOOKUP_FLAGS_DEFAULT,
-						  GPIOD_OUT_LOW);
-	if (IS_ERR(spi->cs_gpiod)) {
-		ret = PTR_ERR(spi->cs_gpiod);
-		goto err_cleanup;
-	}
+	/* and calculate the real CS */
+	spi->cs_gpio = chip->base + 8 - spi->chip_select;
 
 	/* and set up the "mode" and level */
-	dev_info(&spi->dev, "setting up native-CS%i to use GPIO\n",
-		 spi->chip_select);
+	dev_info(&spi->dev, "setting up native-CS%i as GPIO %i\n",
+			spi->chip_select, spi->cs_gpio);
 
-	return 0;
+	/* set up GPIO as output and pull to the correct level */
+	err = gpio_direction_output(spi->cs_gpio,
+								(spi->mode & SPI_CS_HIGH) ? 0 : 1);
+	if (err) {
+		dev_err(&spi->dev,
+				"could not set CS%i gpio %i as output: %i",
+				spi->chip_select, spi->cs_gpio, err);
+		return err;
+	}
 
-err_cleanup:
-	bcm2835_spi_cleanup(spi);
-	return ret;
+	return 0;
 }
 
 static int bcm2835_spi_probe(struct platform_device *pdev)
 {
 	struct spi_controller *ctlr;
 	struct bcm2835_spi *bs;
+	struct resource *res;
 	int err;
 
-	ctlr = devm_spi_alloc_master(&pdev->dev, sizeof(*bs));
+	ctlr = spi_alloc_master(&pdev->dev, sizeof(*bs));
 	if (!ctlr)
 		return -ENOMEM;
 
 	platform_set_drvdata(pdev, ctlr);
 
-	ctlr->use_gpio_descriptors = true;
 	ctlr->mode_bits = BCM2835_SPI_MODE_BITS;
 	ctlr->bits_per_word_mask = SPI_BPW_MASK(8);
 	ctlr->num_chipselect = 3;
 	ctlr->setup = bcm2835_spi_setup;
-	ctlr->cleanup = bcm2835_spi_cleanup;
 	ctlr->transfer_one = bcm2835_spi_transfer_one;
 	ctlr->handle_err = bcm2835_spi_handle_err;
 	ctlr->prepare_message = bcm2835_spi_prepare_message;
@@ -1357,55 +1010,59 @@ static int bcm2835_spi_probe(struct platform_device *pdev)
 	bs = spi_controller_get_devdata(ctlr);
 	bs->ctlr = ctlr;
 
-	bs->regs = devm_platform_ioremap_resource(pdev, 0);
-	if (IS_ERR(bs->regs))
-		return PTR_ERR(bs->regs);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	bs->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(bs->regs)) {
+		err = PTR_ERR(bs->regs);
+		goto out_controller_put;
+	}
 
 	bs->clk = devm_clk_get(&pdev->dev, NULL);
-	if (IS_ERR(bs->clk))
-		return dev_err_probe(&pdev->dev, PTR_ERR(bs->clk),
-				     "could not get clk\n");
+	if (IS_ERR(bs->clk)) {
+		err = PTR_ERR(bs->clk);
+		dev_err(&pdev->dev, "could not get clk: %d\n", err);
+		goto out_controller_put;
+	}
 
 	ctlr->max_speed_hz = clk_get_rate(bs->clk) / 2;
 
 	bs->irq = platform_get_irq(pdev, 0);
-	if (bs->irq <= 0)
-		return bs->irq ? bs->irq : -ENODEV;
+	if (bs->irq <= 0) {
+		dev_err(&pdev->dev, "could not get IRQ: %d\n", bs->irq);
+		err = bs->irq ? bs->irq : -ENODEV;
+		goto out_controller_put;
+	}
 
 	clk_prepare_enable(bs->clk);
-	bs->clk_hz = clk_get_rate(bs->clk);
 
-	err = bcm2835_dma_init(ctlr, &pdev->dev, bs);
-	if (err)
-		goto out_clk_disable;
+	bcm2835_dma_init(ctlr, &pdev->dev);
 
 	/* initialise the hardware with the default polarities */
 	bcm2835_wr(bs, BCM2835_SPI_CS,
 		   BCM2835_SPI_CS_CLEAR_RX | BCM2835_SPI_CS_CLEAR_TX);
 
-	err = devm_request_irq(&pdev->dev, bs->irq, bcm2835_spi_interrupt,
-			       IRQF_SHARED,
-			       dev_name(&pdev->dev), bs);
+	err = devm_request_irq(&pdev->dev, bs->irq, bcm2835_spi_interrupt, 0,
+				dev_name(&pdev->dev), ctlr);
 	if (err) {
 		dev_err(&pdev->dev, "could not request IRQ: %d\n", err);
-		goto out_dma_release;
+		goto out_clk_disable;
 	}
 
-	err = spi_register_controller(ctlr);
+	err = devm_spi_register_controller(&pdev->dev, ctlr);
 	if (err) {
 		dev_err(&pdev->dev, "could not register SPI controller: %d\n",
 			err);
-		goto out_dma_release;
+		goto out_clk_disable;
 	}
 
 	bcm2835_debugfs_create(bs, dev_name(&pdev->dev));
 
 	return 0;
 
-out_dma_release:
-	bcm2835_dma_release(ctlr, bs);
 out_clk_disable:
 	clk_disable_unprepare(bs->clk);
+out_controller_put:
+	spi_controller_put(ctlr);
 	return err;
 }
 
@@ -1416,26 +1073,15 @@ static int bcm2835_spi_remove(struct platform_device *pdev)
 
 	bcm2835_debugfs_remove(bs);
 
-	spi_unregister_controller(ctlr);
-
-	bcm2835_dma_release(ctlr, bs);
-
 	/* Clear FIFOs, and disable the HW block */
 	bcm2835_wr(bs, BCM2835_SPI_CS,
 		   BCM2835_SPI_CS_CLEAR_RX | BCM2835_SPI_CS_CLEAR_TX);
 
 	clk_disable_unprepare(bs->clk);
 
-	return 0;
-}
-
-static void bcm2835_spi_shutdown(struct platform_device *pdev)
-{
-	int ret;
+	bcm2835_dma_release(ctlr);
 
-	ret = bcm2835_spi_remove(pdev);
-	if (ret)
-		dev_err(&pdev->dev, "failed to shutdown\n");
+	return 0;
 }
 
 static const struct of_device_id bcm2835_spi_match[] = {
@@ -1451,7 +1097,6 @@ static struct platform_driver bcm2835_spi_driver = {
 	},
 	.probe		= bcm2835_spi_probe,
 	.remove		= bcm2835_spi_remove,
-	.shutdown	= bcm2835_spi_shutdown,
 };
 module_platform_driver(bcm2835_spi_driver);
 
diff --git a/include/linux/ieee80211.h b/include/linux/ieee80211.h
index 00ed7c17698d..b8fd0787ddbe 100644
--- a/include/linux/ieee80211.h
+++ b/include/linux/ieee80211.h
@@ -3448,6 +3448,9 @@ enum ieee80211_back_actioncode {
 	WLAN_ACTION_ADDBA_REQ = 0,
 	WLAN_ACTION_ADDBA_RESP = 1,
 	WLAN_ACTION_DELBA = 2,
+	WLAN_ACTION_NDP_ADDBA_REQ = 128,
+	WLAN_ACTION_NDP_ADDBA_RESP = 129,
+	WLAN_ACTION_NDP_DELBA = 130,
 };
 
 /* BACK (block-ack) parties */
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 0557b0e5c42c..d53f081ba559 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -292,7 +292,9 @@ struct mmc_card {
 #define MMC_QUIRK_BROKEN_IRQ_POLLING	(1<<11)	/* Polling SDIO_CCCR_INTx could create a fake interrupt */
 #define MMC_QUIRK_TRIM_BROKEN	(1<<12)		/* Skip trim */
 #define MMC_QUIRK_BROKEN_HPI	(1<<13)		/* Disable broken HPI support */
-#define MMC_QUIRK_BROKEN_SD_DISCARD	(1<<14)	/* Disable broken SD discard support */
+#define MMC_QUIRK_NO_18V	(1<<14)		/* Ignore voltage negotiation and don't use 1.8v */
+
+//#define MMC_QUIRK_BROKEN_SD_DISCARD	(1<<14)	/* Disable broken SD discard support */
 
 #define MMC_QUIRK_ERASE_BROKEN	(1<<31)		/* Skip erase */
 
diff --git a/include/net/mac80211.h b/include/net/mac80211.h
index 618d1f427cb2..44bc0979e7f5 100644
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -125,6 +125,13 @@
  * via the usual ieee80211_tx_dequeue).
  */
 
+/** Morse Micro patches which add functionality that the driver needs to know about, can be
+ * signalled by adding a define here.
+ */
+
+/** mac80211 has the capability to negotiate NDP block acknowledgements */
+#define MORSE_MAC80211_S1G_FEATURE_NDP_BLOCKACK
+
 struct device;
 
 /**
@@ -1281,7 +1288,7 @@ ieee80211_tx_info_clear_status(struct ieee80211_tx_info *info)
  * @RX_FLAG_AMPDU_EOF_BIT_KNOWN: The EOF value is known
  * @RX_FLAG_RADIOTAP_HE: HE radiotap data is present
  *	(&struct ieee80211_radiotap_he, mac80211 will fill in
- *	
+ *
  *	 - DATA3_DATA_MCS
  *	 - DATA3_DATA_DCM
  *	 - DATA3_CODING
@@ -1289,7 +1296,7 @@ ieee80211_tx_info_clear_status(struct ieee80211_tx_info *info)
  *	 - DATA5_DATA_BW_RU_ALLOC
  *	 - DATA6_NSTS
  *	 - DATA3_STBC
- *	
+ *
  *	from the RX info data, so leave those zeroed when building this data)
  * @RX_FLAG_RADIOTAP_HE_MU: HE MU radiotap data is present
  *	(&struct ieee80211_radiotap_he_mu)
@@ -2411,6 +2418,9 @@ struct ieee80211_txq {
  *	usage and 802.11 frames with %RX_FLAG_ONLY_MONITOR set for monitor to
  *	the stack.
  *
+ * @IEEE80211_HW_SUPPORTS_NDP_BLOCKACK: Hardware supports 11ah A-MPDU aggregation with NDP block
+ *	ACKs
+ *
  * @NUM_IEEE80211_HW_FLAGS: number of hardware flags, used for sizing arrays
  */
 enum ieee80211_hw_flags {
@@ -2466,6 +2476,7 @@ enum ieee80211_hw_flags {
 	IEEE80211_HW_SUPPORTS_TX_ENCAP_OFFLOAD,
 	IEEE80211_HW_SUPPORTS_RX_DECAP_OFFLOAD,
 	IEEE80211_HW_SUPPORTS_CONC_MON_RX_DECAP,
+	IEEE80211_HW_SUPPORTS_NDP_BLOCKACK,
 
 	/* keep last, obviously */
 	NUM_IEEE80211_HW_FLAGS
@@ -3274,6 +3285,7 @@ enum ieee80211_ampdu_mlme_action {
  *	%IEEE80211_AMPDU_TX_OPERATIONAL
  * @amsdu: indicates the peer's ability to receive A-MSDU within A-MPDU.
  *	valid when the action is set to %IEEE80211_AMPDU_TX_OPERATIONAL
+ * @ndp: indicates the driver has requested the session to use NDP block ACKs
  * @timeout: BA session timeout. Valid only when the action is set to
  *	%IEEE80211_AMPDU_RX_START
  */
@@ -3284,6 +3296,7 @@ struct ieee80211_ampdu_params {
 	u16 ssn;
 	u16 buf_size;
 	bool amsdu;
+	bool ndp;
 	u16 timeout;
 };
 
diff --git a/net/mac80211/agg-rx.c b/net/mac80211/agg-rx.c
index 0d2bab9d351c..1f8a56fbd09c 100644
--- a/net/mac80211/agg-rx.c
+++ b/net/mac80211/agg-rx.c
@@ -80,6 +80,8 @@ void ___ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,
 	RCU_INIT_POINTER(sta->ampdu_mlme.tid_rx[tid], NULL);
 	__clear_bit(tid, sta->ampdu_mlme.agg_session_valid);
 
+	params.ndp = tid_rx ? tid_rx->ndp : false;
+
 	ht_dbg(sta->sdata,
 	       "Rx BA session stop requested for %pM tid %u %s reason: %d\n",
 	       sta->sta.addr, tid,
@@ -94,7 +96,7 @@ void ___ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,
 	/* check if this is a self generated aggregation halt */
 	if (initiator == WLAN_BACK_RECIPIENT && tx)
 		ieee80211_send_delba(sta->sdata, sta->sta.addr,
-				     tid, WLAN_BACK_RECIPIENT, reason);
+				     tid, params.ndp, WLAN_BACK_RECIPIENT, reason);
 
 	/*
 	 * return here in case tid_rx is not assigned - which will happen if
@@ -214,7 +216,7 @@ static void ieee80211_add_addbaext(struct ieee80211_sub_if_data *sdata,
 
 static void ieee80211_send_addba_resp(struct sta_info *sta, u8 *da, u16 tid,
 				      u8 dialog_token, u16 status, u16 policy,
-				      u16 buf_size, u16 timeout,
+				      u16 buf_size, u16 timeout, bool ndp,
 				      const struct ieee80211_addba_ext_ie *addbaext)
 {
 	struct ieee80211_sub_if_data *sdata = sta->sdata;
@@ -248,7 +250,8 @@ static void ieee80211_send_addba_resp(struct sta_info *sta, u8 *da, u16 tid,
 
 	skb_put(skb, 1 + sizeof(mgmt->u.action.u.addba_resp));
 	mgmt->u.action.category = WLAN_CATEGORY_BACK;
-	mgmt->u.action.u.addba_resp.action_code = WLAN_ACTION_ADDBA_RESP;
+	mgmt->u.action.u.addba_resp.action_code = ndp ?
+			WLAN_ACTION_NDP_ADDBA_RESP : WLAN_ACTION_ADDBA_RESP;
 	mgmt->u.action.u.addba_resp.dialog_token = dialog_token;
 
 	capab = u16_encode_bits(amsdu, IEEE80211_ADDBA_PARAM_AMSDU_MASK);
@@ -269,7 +272,7 @@ static void ieee80211_send_addba_resp(struct sta_info *sta, u8 *da, u16 tid,
 void ___ieee80211_start_rx_ba_session(struct sta_info *sta,
 				      u8 dialog_token, u16 timeout,
 				      u16 start_seq_num, u16 ba_policy, u16 tid,
-				      u16 buf_size, bool tx, bool auto_seq,
+				      u16 buf_size, bool tx, bool auto_seq, bool ndp,
 				      const struct ieee80211_addba_ext_ie *addbaext)
 {
 	struct ieee80211_local *local = sta->sdata->local;
@@ -280,6 +283,7 @@ void ___ieee80211_start_rx_ba_session(struct sta_info *sta,
 		.tid = tid,
 		.amsdu = false,
 		.timeout = timeout,
+		.ndp = ndp,
 		.ssn = start_seq_num,
 	};
 	int i, ret = -EOPNOTSUPP;
@@ -302,6 +306,11 @@ void ___ieee80211_start_rx_ba_session(struct sta_info *sta,
 		goto end;
 	}
 
+	if (ndp && !ieee80211_hw_check(&local->hw, SUPPORTS_NDP_BLOCKACK)) {
+		ht_dbg(sta->sdata, "Requested NDP BA but HW does not support it\n");
+		goto end;
+	}
+
 	if (test_sta_flag(sta, WLAN_STA_BLOCK_BA)) {
 		ht_dbg(sta->sdata,
 		       "Suspend in progress - Denying ADDBA request (%pM tid %d)\n",
@@ -434,6 +443,7 @@ void ___ieee80211_start_rx_ba_session(struct sta_info *sta,
 	tid_agg_rx->started = false;
 	tid_agg_rx->reorder_buf_filtered = 0;
 	tid_agg_rx->tid = tid;
+	tid_agg_rx->ndp = params.ndp;
 	tid_agg_rx->sta = sta;
 	status = WLAN_STATUS_SUCCESS;
 
@@ -455,20 +465,20 @@ void ___ieee80211_start_rx_ba_session(struct sta_info *sta,
 	if (tx)
 		ieee80211_send_addba_resp(sta, sta->sta.addr, tid,
 					  dialog_token, status, 1, buf_size,
-					  timeout, addbaext);
+					  timeout, params.ndp, addbaext);
 }
 
 static void __ieee80211_start_rx_ba_session(struct sta_info *sta,
 					    u8 dialog_token, u16 timeout,
 					    u16 start_seq_num, u16 ba_policy,
 					    u16 tid, u16 buf_size, bool tx,
-					    bool auto_seq,
+					    bool auto_seq, bool ndp,
 					    const struct ieee80211_addba_ext_ie *addbaext)
 {
 	mutex_lock(&sta->ampdu_mlme.mtx);
 	___ieee80211_start_rx_ba_session(sta, dialog_token, timeout,
 					 start_seq_num, ba_policy, tid,
-					 buf_size, tx, auto_seq, addbaext);
+					 buf_size, tx, auto_seq, ndp, addbaext);
 	mutex_unlock(&sta->ampdu_mlme.mtx);
 }
 
@@ -481,6 +491,7 @@ void ieee80211_process_addba_request(struct ieee80211_local *local,
 	struct ieee802_11_elems *elems = NULL;
 	u8 dialog_token;
 	int ies_len;
+	bool ndp_ba;
 
 	/* extract session parameters from addba request frame */
 	dialog_token = mgmt->u.action.u.addba_req.dialog_token;
@@ -492,6 +503,7 @@ void ieee80211_process_addba_request(struct ieee80211_local *local,
 	ba_policy = (capab & IEEE80211_ADDBA_PARAM_POLICY_MASK) >> 1;
 	tid = (capab & IEEE80211_ADDBA_PARAM_TID_MASK) >> 2;
 	buf_size = (capab & IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK) >> 6;
+	ndp_ba = (mgmt->u.action.u.addba_req.action_code == WLAN_ACTION_NDP_ADDBA_REQ);
 
 	ies_len = len - offsetof(struct ieee80211_mgmt,
 				 u.action.u.addba_req.variable);
@@ -504,7 +516,7 @@ void ieee80211_process_addba_request(struct ieee80211_local *local,
 
 	__ieee80211_start_rx_ba_session(sta, dialog_token, timeout,
 					start_seq_num, ba_policy, tid,
-					buf_size, true, false,
+					buf_size, true, false, ndp_ba,
 					elems ? elems->addba_ext_ie : NULL);
 free:
 	kfree(elems);
diff --git a/net/mac80211/agg-tx.c b/net/mac80211/agg-tx.c
index a4d3fa14f76b..4dcfdad8a4a6 100644
--- a/net/mac80211/agg-tx.c
+++ b/net/mac80211/agg-tx.c
@@ -59,7 +59,7 @@
  */
 
 static void ieee80211_send_addba_request(struct ieee80211_sub_if_data *sdata,
-					 const u8 *da, u16 tid,
+					 const u8 *da, u16 tid, bool ndp,
 					 u8 dialog_token, u16 start_seq_num,
 					 u16 agg_size, u16 timeout)
 {
@@ -92,7 +92,8 @@ static void ieee80211_send_addba_request(struct ieee80211_sub_if_data *sdata,
 	skb_put(skb, 1 + sizeof(mgmt->u.action.u.addba_req));
 
 	mgmt->u.action.category = WLAN_CATEGORY_BACK;
-	mgmt->u.action.u.addba_req.action_code = WLAN_ACTION_ADDBA_REQ;
+	mgmt->u.action.u.addba_req.action_code = ndp ? WLAN_ACTION_NDP_ADDBA_REQ :
+			WLAN_ACTION_ADDBA_REQ;
 
 	mgmt->u.action.u.addba_req.dialog_token = dialog_token;
 	capab = IEEE80211_ADDBA_PARAM_AMSDU_MASK;
@@ -340,6 +341,8 @@ int ___ieee80211_stop_tx_ba_session(struct sta_info *sta, u16 tid,
 		return -ENOENT;
 	}
 
+	params.ndp = tid_tx->ndp;
+
 	/*
 	 * if we're already stopping ignore any new requests to stop
 	 * unless we're destroying it in which case notify the driver
@@ -480,7 +483,7 @@ static void ieee80211_send_addba_with_timeout(struct sta_info *sta,
 	}
 
 	/* send AddBA request */
-	ieee80211_send_addba_request(sdata, sta->sta.addr, tid,
+	ieee80211_send_addba_request(sdata, sta->sta.addr, tid, tid_tx->ndp,
 				     tid_tx->dialog_token, tid_tx->ssn,
 				     buf_size, tid_tx->timeout);
 
@@ -498,10 +501,18 @@ void ieee80211_tx_ba_session_handle_start(struct sta_info *sta, int tid)
 		.tid = tid,
 		.buf_size = 0,
 		.amsdu = false,
+		.ndp = false,
 		.timeout = 0,
 	};
 	int ret;
 
+	/* If the HW supports NDP blockacks, try to negotiate. It's the drivers responsibility to
+	 * clear .ndp if the conditions for NDP block acks are not met for this TID.
+	 * TODO: remove driver responsibility when S1G STA caps exist in mac80211
+	 */
+	if (ieee80211_hw_check(&local->hw, SUPPORTS_NDP_BLOCKACK))
+		params.ndp = true;
+
 	tid_tx = rcu_dereference_protected_tid_tx(sta, tid);
 
 	/*
@@ -525,6 +536,10 @@ void ieee80211_tx_ba_session_handle_start(struct sta_info *sta, int tid)
 	params.ssn = sta->tid_seq[tid] >> 4;
 	ret = drv_ampdu_action(local, sdata, &params);
 	tid_tx->ssn = params.ssn;
+
+	/* driver may clear this flag if it does not want NDP for this session */
+	tid_tx->ndp = params.ndp;
+
 	if (ret == IEEE80211_AMPDU_TX_START_DELAY_ADDBA) {
 		return;
 	} else if (ret == IEEE80211_AMPDU_TX_START_IMMEDIATE) {
@@ -748,6 +763,7 @@ static void ieee80211_agg_tx_operational(struct ieee80211_local *local,
 	tid_tx = rcu_dereference_protected_tid_tx(sta, tid);
 	params.buf_size = tid_tx->buf_size;
 	params.amsdu = tid_tx->amsdu;
+	params.ndp = tid_tx->ndp;
 
 	ht_dbg(sta->sdata, "Aggregation is on for %pM tid %d\n",
 	       sta->sta.addr, tid);
@@ -929,7 +945,7 @@ void ieee80211_stop_tx_ba_cb(struct sta_info *sta, int tid,
 		ieee80211_agg_start_txq(sta, tid, false);
 
 	if (send_delba)
-		ieee80211_send_delba(sdata, sta->sta.addr, tid,
+		ieee80211_send_delba(sdata, sta->sta.addr, tid, tid_tx->ndp,
 			WLAN_BACK_INITIATOR, WLAN_REASON_QSTA_NOT_USE);
 }
 
@@ -988,6 +1004,13 @@ void ieee80211_process_addba_resp(struct ieee80211_local *local,
 		goto out;
 	}
 
+	if ((tid_tx->ndp && mgmt->u.action.u.addba_resp.action_code != WLAN_ACTION_NDP_ADDBA_RESP) ||
+			(!tid_tx->ndp && mgmt->u.action.u.addba_resp.action_code != WLAN_ACTION_ADDBA_RESP)) {
+		ht_dbg(sta->sdata, "wrong addBA response action code, %d ndp %d\n",
+				mgmt->u.action.u.addba_resp.action_code, tid_tx->ndp);
+		goto out;
+	}
+
 	del_timer_sync(&tid_tx->addba_resp_timer);
 
 	ht_dbg(sta->sdata, "switched off addBA timer for %pM tid %d\n",
diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
index 4fa216a108ae..0cdfa531d8c4 100644
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -1749,6 +1749,10 @@ static int ieee80211_add_station(struct wiphy *wiphy, struct net_device *dev,
 		return err;
 	}
 
+    if (ieee80211_vif_is_mesh(&sdata->vif)) {
+        mesh_update_mfp_flag(sdata,sta);
+    }
+
 	/*
 	 * for TDLS and for unassociated station, rate control should be
 	 * initialized only when rates are known and station is marked
diff --git a/net/mac80211/chan.c b/net/mac80211/chan.c
index 63e15f583e0a..33ca0982ff2d 100644
--- a/net/mac80211/chan.c
+++ b/net/mac80211/chan.c
@@ -376,11 +376,6 @@ static void ieee80211_chan_bw_change(struct ieee80211_local *local,
 		if (new_sta_bw == sta->sta.bandwidth)
 			continue;
 
-		/* vif changed to narrow BW and narrow BW for station wasn't
-		 * requested or vise versa */
-		if ((new_sta_bw < sta->sta.bandwidth) == !narrowed)
-			continue;
-
 		sta->sta.bandwidth = new_sta_bw;
 		rate_control_rate_update(local, sband, sta,
 					 IEEE80211_RC_BW_CHANGED);
diff --git a/net/mac80211/debugfs.c b/net/mac80211/debugfs.c
index 8dbfe325ee66..6921afa1af07 100644
--- a/net/mac80211/debugfs.c
+++ b/net/mac80211/debugfs.c
@@ -504,6 +504,7 @@ static const char *hw_flag_names[] = {
 	FLAG(SUPPORTS_TX_ENCAP_OFFLOAD),
 	FLAG(SUPPORTS_RX_DECAP_OFFLOAD),
 	FLAG(SUPPORTS_CONC_MON_RX_DECAP),
+	FLAG(SUPPORTS_NDP_BLOCKACK),
 #undef FLAG
 };
 
diff --git a/net/mac80211/ht.c b/net/mac80211/ht.c
index 2eb7641f5556..2ecb3ec94f41 100644
--- a/net/mac80211/ht.c
+++ b/net/mac80211/ht.c
@@ -365,7 +365,7 @@ void ieee80211_ba_session_work(struct work_struct *work)
 				       sta->ampdu_mlme.tid_rx_manage_offl))
 			___ieee80211_start_rx_ba_session(sta, 0, 0, 0, 1, tid,
 							 IEEE80211_MAX_AMPDU_BUF_HT,
-							 false, true, NULL);
+							 false, true, false, NULL);
 
 		if (test_and_clear_bit(tid + IEEE80211_NUM_TIDS,
 				       sta->ampdu_mlme.tid_rx_manage_offl))
@@ -412,7 +412,7 @@ void ieee80211_ba_session_work(struct work_struct *work)
 }
 
 void ieee80211_send_delba(struct ieee80211_sub_if_data *sdata,
-			  const u8 *da, u16 tid,
+			  const u8 *da, u16 tid, bool ndp,
 			  u16 initiator, u16 reason_code)
 {
 	struct ieee80211_local *local = sdata->local;
@@ -443,7 +443,7 @@ void ieee80211_send_delba(struct ieee80211_sub_if_data *sdata,
 	skb_put(skb, 1 + sizeof(mgmt->u.action.u.delba));
 
 	mgmt->u.action.category = WLAN_CATEGORY_BACK;
-	mgmt->u.action.u.delba.action_code = WLAN_ACTION_DELBA;
+	mgmt->u.action.u.delba.action_code = ndp ? WLAN_ACTION_NDP_DELBA : WLAN_ACTION_DELBA;
 	params = (u16)(initiator << 11); 	/* bit 11 initiator */
 	params |= (u16)(tid << 12); 		/* bit 15:12 TID number */
 
diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
index 21549a440b38..e91a9c3a291b 100644
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -745,6 +745,10 @@ struct ieee80211_if_mesh {
 	struct mesh_table mpp_paths; /* Store paths for MPP&MAP */
 	int mesh_paths_generation;
 	int mpp_paths_generation;
+    enum {
+        IEEE80211_MESH_MFP_DISABLED,
+        IEEE80211_MESH_MFP_ENABLED,
+    } mfp; /* management frame protection */
 };
 
 #ifdef CONFIG_MAC80211_MESH
@@ -2022,7 +2026,7 @@ bool ieee80211_ht_cap_ie_to_sta_ht_cap(struct ieee80211_sub_if_data *sdata,
 				       const struct ieee80211_ht_cap *ht_cap_ie,
 				       struct sta_info *sta);
 void ieee80211_send_delba(struct ieee80211_sub_if_data *sdata,
-			  const u8 *da, u16 tid,
+			  const u8 *da, u16 tid, bool ndp,
 			  u16 initiator, u16 reason_code);
 int ieee80211_send_smps_action(struct ieee80211_sub_if_data *sdata,
 			       enum ieee80211_smps_mode smps, const u8 *da,
@@ -2039,7 +2043,7 @@ void __ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,
 void ___ieee80211_start_rx_ba_session(struct sta_info *sta,
 				      u8 dialog_token, u16 timeout,
 				      u16 start_seq_num, u16 ba_policy, u16 tid,
-				      u16 buf_size, bool tx, bool auto_seq,
+				      u16 buf_size, bool tx, bool auto_seq, bool ndp,
 				      const struct ieee80211_addba_ext_ie *addbaext);
 void ieee80211_sta_tear_down_BA_sessions(struct sta_info *sta,
 					 enum ieee80211_agg_stop_reason reason);
diff --git a/net/mac80211/iface.c b/net/mac80211/iface.c
index 041859b5b71d..05dcba4ecdea 100644
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@ -1339,14 +1339,17 @@ static void ieee80211_iface_process_skb(struct ieee80211_local *local,
 		if (sta) {
 			switch (mgmt->u.action.u.addba_req.action_code) {
 			case WLAN_ACTION_ADDBA_REQ:
+			case WLAN_ACTION_NDP_ADDBA_REQ:
 				ieee80211_process_addba_request(local, sta,
 								mgmt, len);
 				break;
 			case WLAN_ACTION_ADDBA_RESP:
+			case WLAN_ACTION_NDP_ADDBA_RESP:
 				ieee80211_process_addba_resp(local, sta,
 							     mgmt, len);
 				break;
 			case WLAN_ACTION_DELBA:
+			case WLAN_ACTION_NDP_DELBA:
 				ieee80211_process_delba(sdata, sta,
 							mgmt, len);
 				break;
diff --git a/net/mac80211/mesh.c b/net/mac80211/mesh.c
index 6847fdf93439..f94c39a7d533 100644
--- a/net/mac80211/mesh.c
+++ b/net/mac80211/mesh.c
@@ -1561,6 +1561,19 @@ void ieee80211_mesh_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,
 	sdata_unlock(sdata);
 }
 
+void mesh_update_mfp_flag(struct ieee80211_sub_if_data *sdata, struct sta_info *sta)
+{
+    struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+    if (test_sta_flag(sta, WLAN_STA_MFP))
+    {
+        mpl_dbg(sdata,"%s: Mesh MFP Enabled\n",__func__);
+        ifmsh->mfp = IEEE80211_MESH_MFP_ENABLED;
+    } else {
+        mpl_dbg(sdata,"%s: Mesh MFP Disabled\n",__func__);
+        ifmsh->mfp = IEEE80211_MESH_MFP_DISABLED;
+    }
+}
+
 static void mesh_bss_info_changed(struct ieee80211_sub_if_data *sdata)
 {
 	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
diff --git a/net/mac80211/mesh.h b/net/mac80211/mesh.h
index b2b717a78114..5d281627ea33 100644
--- a/net/mac80211/mesh.h
+++ b/net/mac80211/mesh.h
@@ -339,12 +339,15 @@ static inline bool mesh_path_sel_is_hwmp(struct ieee80211_sub_if_data *sdata)
 void mesh_path_flush_by_iface(struct ieee80211_sub_if_data *sdata);
 void mesh_sync_adjust_tsf(struct ieee80211_sub_if_data *sdata);
 void ieee80211s_stop(void);
+void mesh_update_mfp_flag(struct ieee80211_sub_if_data *sdata, struct sta_info *sta);
 #else
 static inline bool mesh_path_sel_is_hwmp(struct ieee80211_sub_if_data *sdata)
 { return false; }
 static inline void mesh_path_flush_by_iface(struct ieee80211_sub_if_data *sdata)
 {}
 static inline void ieee80211s_stop(void) {}
+static inline void mesh_update_mfp_flag(struct ieee80211_sub_if_data *sdata, struct sta_info *sta)
+{}
 #endif
 
 #endif /* IEEE80211S_H */
diff --git a/net/mac80211/mesh_hwmp.c b/net/mac80211/mesh_hwmp.c
index 44a6fdb6efbd..1a9451b9b3ea 100644
--- a/net/mac80211/mesh_hwmp.c
+++ b/net/mac80211/mesh_hwmp.c
@@ -190,6 +190,8 @@ static int mesh_path_sel_frame_tx(enum mpath_frame_type action, u8 flags,
 		pos += 4;
 	}
 
+    if (sdata->u.mesh.mfp == IEEE80211_MESH_MFP_DISABLED)
+        IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
 	ieee80211_tx_skb(sdata, skb);
 	return 0;
 }
diff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c
index cc6d38a2e6d5..8c09c881cdcc 100644
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -1321,6 +1321,26 @@ ieee80211_sta_process_chanswitch(struct ieee80211_sub_if_data *sdata,
 
 	current_band = cbss->channel->band;
 	bss = (void *)cbss->priv;
+	if (elems->wide_bw_chansw_ie) {
+		struct ieee80211_supported_band *sband = ieee80211_get_sband(sdata);
+
+		/* if wide bw is included then we are moving to HT or VHT channels,
+		 * so enable modes accordingly
+		 */
+		if (sband->ht_cap.ht_supported && (ifmgd->flags &
+				(IEEE80211_STA_DISABLE_HT | IEEE80211_STA_DISABLE_40MHZ))) {
+			ifmgd->flags &= ~(IEEE80211_STA_DISABLE_HT | IEEE80211_STA_DISABLE_40MHZ);
+			sdata_info(sdata,"mac80211: %s: updated if flags=0x%x\n",__func__, ifmgd->flags);
+		}
+
+		if ((elems->wide_bw_chansw_ie->new_channel_width > IEEE80211_VHT_CHANWIDTH_USE_HT) &&
+					sband->vht_cap.vht_supported &&
+					(ifmgd->flags & (IEEE80211_STA_DISABLE_VHT | IEEE80211_STA_DISABLE_160MHZ))) {
+			ifmgd->flags &= ~(IEEE80211_STA_DISABLE_VHT | IEEE80211_STA_DISABLE_160MHZ);
+			sdata_info(sdata,"mac80211: %s: updated vht caps, if flags=0x%x\n",__func__, ifmgd->flags);
+		}
+	}
+
 	res = ieee80211_parse_ch_switch_ie(sdata, elems, current_band,
 					   bss->vht_cap_info,
 					   ifmgd->flags,
@@ -1453,9 +1473,9 @@ ieee80211_sta_process_chanswitch(struct ieee80211_sub_if_data *sdata,
 	/* channel switch handled in software */
 	if (csa_ie.count <= 1)
 		ieee80211_queue_work(&local->hw, &ifmgd->chswitch_work);
-	else
+	else /* consider short beacons time also */
 		mod_timer(&ifmgd->chswitch_timer,
-			  TU_TO_EXP_TIME((csa_ie.count - 1) *
+			  TU_TO_EXP_TIME((csa_ie.count - 1) * sdata->vif.bss_conf.dtim_period *
 					 cbss->beacon_interval));
 	return;
  lock_and_drop_connection:
diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c
index 175ead6b19cb..426adf1c03ea 100644
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -1389,7 +1389,7 @@ static void ieee80211_rx_reorder_ampdu(struct ieee80211_rx_data *rx,
 		if (ack_policy == IEEE80211_QOS_CTL_ACK_POLICY_BLOCKACK &&
 		    !test_bit(tid, rx->sta->ampdu_mlme.agg_session_valid) &&
 		    !test_and_set_bit(tid, rx->sta->ampdu_mlme.unexpected_agg))
-			ieee80211_send_delba(rx->sdata, rx->sta->sta.addr, tid,
+			ieee80211_send_delba(rx->sdata, rx->sta->sta.addr, tid, false,
 					     WLAN_BACK_RECIPIENT,
 					     WLAN_REASON_QSTA_REQUIRE_SETUP);
 		goto dont_reorder;
@@ -3064,6 +3064,7 @@ ieee80211_rx_h_ctrl(struct ieee80211_rx_data *rx, struct sk_buff_head *frames)
 {
 	struct sk_buff *skb = rx->skb;
 	struct ieee80211_bar *bar = (struct ieee80211_bar *)skb->data;
+	struct ieee80211_mgmt *back = (struct ieee80211_mgmt *)skb->data;
 	struct tid_ampdu_rx *tid_agg_rx;
 	u16 start_seq_num;
 	u16 tid;
@@ -3090,7 +3091,7 @@ ieee80211_rx_h_ctrl(struct ieee80211_rx_data *rx, struct sk_buff_head *frames)
 
 		if (!test_bit(tid, rx->sta->ampdu_mlme.agg_session_valid) &&
 		    !test_and_set_bit(tid, rx->sta->ampdu_mlme.unexpected_agg))
-			ieee80211_send_delba(rx->sdata, rx->sta->sta.addr, tid,
+			ieee80211_send_delba(rx->sdata, rx->sta->sta.addr, tid, false,
 					     WLAN_BACK_RECIPIENT,
 					     WLAN_REASON_QSTA_REQUIRE_SETUP);
 
@@ -3458,16 +3459,19 @@ ieee80211_rx_h_action(struct ieee80211_rx_data *rx)
 
 		switch (mgmt->u.action.u.addba_req.action_code) {
 		case WLAN_ACTION_ADDBA_REQ:
+		case WLAN_ACTION_NDP_ADDBA_REQ:
 			if (len < (IEEE80211_MIN_ACTION_SIZE +
 				   sizeof(mgmt->u.action.u.addba_req)))
 				goto invalid;
 			break;
 		case WLAN_ACTION_ADDBA_RESP:
+		case WLAN_ACTION_NDP_ADDBA_RESP:
 			if (len < (IEEE80211_MIN_ACTION_SIZE +
 				   sizeof(mgmt->u.action.u.addba_resp)))
 				goto invalid;
 			break;
 		case WLAN_ACTION_DELBA:
+		case WLAN_ACTION_NDP_DELBA:
 			if (len < (IEEE80211_MIN_ACTION_SIZE +
 				   sizeof(mgmt->u.action.u.delba)))
 				goto invalid;
@@ -4125,8 +4129,10 @@ static bool ieee80211_accept_frame(struct ieee80211_rx_data *rx)
 	case NL80211_IFTYPE_STATION:
 		if (!bssid && !sdata->u.mgd.use_4addr)
 			return false;
+#if 0
 		if (ieee80211_is_robust_mgmt_frame(skb) && !rx->sta)
 			return false;
+#endif
 		if (multicast)
 			return true;
 		return ether_addr_equal(sdata->vif.addr, hdr->addr1);
diff --git a/net/mac80211/sta_info.h b/net/mac80211/sta_info.h
index e7443fc4669c..3f324373c239 100644
--- a/net/mac80211/sta_info.h
+++ b/net/mac80211/sta_info.h
@@ -176,6 +176,7 @@ struct sta_info;
  * @failed_bar_ssn: ssn of the last failed BAR tx attempt
  * @bar_pending: BAR needs to be re-sent
  * @amsdu: support A-MSDU withing A-MDPU
+ * @ndp: this session is using NDP block ACKs
  *
  * This structure's lifetime is managed by RCU, assignments to
  * the array holding it must hold the aggregation mutex.
@@ -204,6 +205,7 @@ struct tid_ampdu_tx {
 	u16 failed_bar_ssn;
 	bool bar_pending;
 	bool amsdu;
+	bool ndp;
 	u8 tid;
 };
 
@@ -231,6 +233,7 @@ struct tid_ampdu_tx {
  *	and ssn.
  * @removed: this session is removed (but might have been found due to RCU)
  * @started: this session has started (head ssn or higher was received)
+ * @ndp: this session is using NDP block ACKs
  *
  * This structure's lifetime is managed by RCU, assignments to
  * the array holding it must hold the aggregation mutex.
@@ -258,7 +261,8 @@ struct tid_ampdu_rx {
 	u8 tid;
 	u8 auto_seq:1,
 	   removed:1,
-	   started:1;
+	   started:1,
+	   ndp:1;
 };
 
 /**
diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c
index 8f8dc2625d53..16fe40b69b8a 100644
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -4200,6 +4200,12 @@ void __ieee80211_subif_start_xmit(struct sk_buff *skb,
 		if (fast_tx &&
 		    ieee80211_xmit_fast(sdata, sta, fast_tx, skb))
 			goto out;
+	} else if (ieee80211_vif_is_mesh(&sdata->vif)) {
+		/* For mesh interface, sta is determined in ieee80211_tx_prepare after building
+		 * mesh header. Update tx pacing shift here, otherwise it affects TCP throughput as
+		 * there won't be enough packets to aggregate.
+		 */
+		sk_pacing_shift_update(skb->sk, sdata->local->hw.tx_sk_pacing_shift);
 	}
 
 	if (skb_is_gso(skb)) {
@@ -4843,7 +4849,9 @@ static void ieee80211_set_beacon_cntdwn(struct ieee80211_sub_if_data *sdata,
 
 static u8 __ieee80211_beacon_update_cntdwn(struct beacon_data *beacon)
 {
-	beacon->cntdwn_current_counter--;
+	/* Avoid updating once the countdown is complete */
+	if (beacon->cntdwn_current_counter > 1)
+		beacon->cntdwn_current_counter--;
 
 	/* the counter should never reach 0 */
 	WARN_ON_ONCE(!beacon->cntdwn_current_counter);
@@ -5016,10 +5024,15 @@ __ieee80211_beacon_get(struct ieee80211_hw *hw,
 
 	if (sdata->vif.type == NL80211_IFTYPE_AP) {
 		struct ieee80211_if_ap *ap = &sdata->u.ap;
+		bool short_beacon = (vif->bss_conf.dtim_period > 1);
+
+		if (ap->ps.dtim_count > 0)
+			short_beacon = ((ap->ps.dtim_count-1) != 0);
 
 		beacon = rcu_dereference(ap->beacon);
 		if (beacon) {
-			if (beacon->cntdwn_counter_offsets[0]) {
+			/* Do not count channel switch count for short beacons */
+			if (beacon->cntdwn_counter_offsets[0] && !short_beacon) {
 				if (!is_template)
 					ieee80211_beacon_update_cntdwn(vif);
 
diff --git a/net/wireless/core.c b/net/wireless/core.c
index 441136646f89..6792225cc00e 100644
--- a/net/wireless/core.c
+++ b/net/wireless/core.c
@@ -1299,8 +1299,8 @@ void cfg80211_init_wdev(struct wireless_dev *wdev)
 	wdev->ps_timeout = -1;
 
 	if ((wdev->iftype == NL80211_IFTYPE_STATION ||
-	     wdev->iftype == NL80211_IFTYPE_P2P_CLIENT ||
-	     wdev->iftype == NL80211_IFTYPE_ADHOC) && !wdev->use_4addr)
+	     wdev->iftype == NL80211_IFTYPE_P2P_CLIENT) &&
+        !wdev->use_4addr)
 		wdev->netdev->priv_flags |= IFF_DONT_BRIDGE;
 
 	INIT_WORK(&wdev->disconnect_wk, cfg80211_autodisconnect_wk);
diff --git a/net/wireless/util.c b/net/wireless/util.c
index cb15d7f4eb05..789e953e601f 100644
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -1087,7 +1087,6 @@ int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
 			fallthrough;
 		case NL80211_IFTYPE_OCB:
 		case NL80211_IFTYPE_P2P_CLIENT:
-		case NL80211_IFTYPE_ADHOC:
 			dev->priv_flags |= IFF_DONT_BRIDGE;
 			break;
 		case NL80211_IFTYPE_P2P_GO:
